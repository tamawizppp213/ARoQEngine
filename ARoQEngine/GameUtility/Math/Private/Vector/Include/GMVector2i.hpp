//////////////////////////////////////////////////////////////////////////////////
///  @file   GMVector2i.hpp
///  @brief  Int型のベクトル2クラスです. ほかのVector2f, 2dと異なりサイズが不定のため, @n
///          Simdを使用しない方針を採用しています. @n
///          また, Float2のようなデータ構造と計算部分を分離する構造もアラインメント調整などが不要なため, @n
///          Int2型などの導入も不要と判断いたしました.
///  @author toide
///  @date   2024/04/21 19:02:30
//////////////////////////////////////////////////////////////////////////////////
#pragma once
#ifndef GM_VECTOR2I_HPP
#define GM_VECTOR2I_HPP

//////////////////////////////////////////////////////////////////////////////////
//                             Include
//////////////////////////////////////////////////////////////////////////////////
#include "GameUtility/Base/Include/GUType.hpp"

//////////////////////////////////////////////////////////////////////////////////
//                              Define
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//                               Class
//////////////////////////////////////////////////////////////////////////////////

namespace gm
{
	/****************************************************************************
	*				  			   Vector2i
	****************************************************************************/
	/*  @struct Vector2i
	*   @brief  Int型のベクトル3クラスです. ほかのVector3f, 3dと異なりサイズが不定のため, @n
	*           Simdを使用しない方針を採用しています. そのため, 計算速度面は遅いので考慮が必要です. @n
	*           また, Float3のようなデータ構造と計算部分を分離する構造もアラインメント調整などが不要なため,@n
	*           Int3型などの導入も不要と判断いたしました.  
	*****************************************************************************/
	template<typename IntType>
	struct Vector2i
	{
	public:
		#pragma region Public Property
		IntType x;  //!< 第1要素
		IntType y;  //!< 第2要素

		/*!**********************************************************************
		*  @brief     Zeroベクトルを返します
		*************************************************************************/
		static Vector2i Zero() { return Vector2i(0, 0); }

		/*!**********************************************************************
		*  @brief     Oneベクトルを返します
		*************************************************************************/
		static Vector2i One()  { return Vector2i(1, 1); }

		/*!**********************************************************************
		*  @brief     XAxisベクトルを返します
		*************************************************************************/
		static Vector2i XAxis() { return Vector2i(1, 0); }

		/*!**********************************************************************
		*  @brief     YAxisベクトルを返します
		*************************************************************************/
		static Vector2i YAxis() { return Vector2i(0, 1); }

		#pragma endregion 

		#pragma region Public Function
		/*!**********************************************************************
		*  @brief     0ベクトルかどうかを返します
		*************************************************************************/
		__forceinline bool IsZero() { return *this == Vector2i(0, 0); }

		#pragma endregion 

		#pragma region Public Operator 
		/*! @brief 加算*/
		__forceinline Vector2i operator+ (const Vector2i& right) const { return Vector2i(x + right.x, y + right.y); }

		/*! @brief 減算*/
		__forceinline Vector2i operator- (const Vector2i& right) const { return Vector2i(x - right.x, y - right.y); }

		/*! @brief 乗算*/
		__forceinline Vector2i operator* (const Vector2i& right) const { return Vector2i(x * right.x, y * right.y); }

		/*! @brief 除算*/
		__forceinline Vector2i operator/ (const Vector2i& right) const { return Vector2i(x / right.x, y / right.y); }

		/*! @brief 余り*/
		__forceinline Vector2i operator% (const Vector2i& right) const { return Vector2i(x % right.x, y % right.y); }

		/*! @brief スカラー倍*/
		__forceinline Vector2i operator* (const IntType right) const { return Vector2i(x * right, y * right); }

		/*! @brief スカラー倍*/
		__forceinline friend Vector2i operator* (const IntType left, const Vector2i& right) { return Vector2i(left * right.x, left * right.y); }

		/*! @brief スカラーで除算*/
		__forceinline Vector2i operator/ (const IntType right) const { return Vector2i(x / right, y / right); }

		/*! @brief スカラーで除算*/
		__forceinline friend Vector2i operator/ (const IntType left, const Vector2i& right) { return Vector2i(left / right.x, left / right.y); }

		/*! @brief 加算*/
		__forceinline Vector2i& operator +=(const Vector2i& right) { *this = *this + right; return *this; }

		/*! @brief 減算*/
		__forceinline Vector2i& operator -=(const Vector2i& right) { *this = *this - right; return *this; }

		/*! @brief 乗算*/
		__forceinline Vector2i& operator *=(const Vector2i& right) { *this = *this * right; return *this; }

		/*! @brief 除算*/
		__forceinline Vector2i& operator /=(const Vector2i& right) { *this = *this / right; return *this; }

		/*! @brief 全ての要素が等しいか*/
		__forceinline bool operator ==(const Vector2i& right) const noexcept
		{
			return x == right.x && y == right.y;
		}

		/*! @brief 一つでも要素が異なるか*/
		__forceinline bool operator !=(const Vector2i& right) const noexcept
		{
			return x != right.x || y != right.y;
		}

		/*! @brief 全ての要素で大きいか*/
		__forceinline bool operator > (const Vector2i& right) const noexcept
		{
			return x > right.x && y > right.y;
		}

		/*! @brief 全ての要素で大きい or 等しいか*/
		__forceinline bool operator >= (const Vector2i& right) const noexcept
		{
			return x >= right.x && y >= right.y;
		}

		/*! @brief 全ての要素で大きいか*/
		__forceinline bool operator < (const Vector2i& right) const noexcept
		{
			return x < right.x && y < right.y;
		}

		/*! @brief 全ての要素で大きい or 等しいか*/
		__forceinline bool operator <= (const Vector2i& right) const noexcept
		{
			return x <= right.x && y <= right.y;
		}

		/*! @brief 右シフト*/
		__forceinline Vector2i operator >> (const IntType right) const { return Vector2i(x >> right, y >> right); }

		/*! @brief 左シフト*/
		__forceinline Vector2i operator << (const IntType right) const { return Vector2i(x << right, y << right); }

		/*! @brief bit and */
		__forceinline Vector2i operator &(const IntType right) const { return Vector2i(x & right, y & right); }

		/*! @brief bit or */
		__forceinline Vector2i operator |(const IntType right) const { return Vector2i(x | right, y | right); }

		/*! @brief bit xor*/
		__forceinline Vector2i operator ^(const IntType right) const { return Vector2i(x ^ right, y ^ right); }
		#pragma endregion 

		#pragma region Public Constructor and Destructor
		/*! @brief デフォルトコンストラクタ*/
		Vector2i() : x(0), y(0) {};

		/*! @brief 一つの要素で初期化*/
		Vector2i(const IntType value) : x(value), y(value) {};

		/*! @brief 全ての要素で初期化*/
		Vector2i(const IntType ix, const IntType iy, const IntType iz) : x(ix), y(iy){};

		/*! @brief 配列を使って初期化*/
		explicit Vector2i(const IntType* array) noexcept : x(array[0]), y(array[1]) {};

		/*! @brief コピーコンストラクタ*/
		Vector2i(const Vector2i<IntType>&) = default;

		/*! @brief コピーコンストラクタ*/
		Vector2i& operator=(const Vector2i<IntType>&) = default;

		/*! @brief ムーブコンストラクタ*/
		Vector2i(Vector2i<IntType>&&) = default;

		/*! @brief ムーブコンストラクタ*/
		Vector2i& operator=(Vector2i<IntType>&&) = default;
		#pragma endregion 

	protected:
		#pragma region Protected Constructor and Destructor

		#pragma endregion 

		#pragma region Protected Function

		#pragma endregion 

		#pragma region Protected Property

		#pragma endregion

	private:
		#pragma region Private Constructor and Destructor

		#pragma endregion

		#pragma region Private Function

		#pragma endregion 

		#pragma region Private Property

		#pragma endregion 

	};
}

#endif